# arduino-maze-robot
## 记录连线
**面包板上连线记录！！连好之后勿动，节约每次测试前的时间！！！**
* 传感器的供电全部使用Arduino 5v；
* Motor， graspper lifter的供电直接使用充电宝；
* 面包板一侧的负极一条公共地，正极一条全部是电动机的5v供电；
* LED校准状态指示灯直接连Arduino的pin13；
* MOtor的pin11左 pin12右；
* Reflectance sensor的1-6对应Arduino的pin8-3，**保证传感器（小车）的左右和屏幕上的左右是一致的**。


##  解决PID和landscape不兼容的问题
 分析：PID算法工作是基于sensor的1-6， 接Arduino的8-3;
      Arduino的3-8一定对应屏幕上的sensorValues0-5;

 landscape算法基于sensor的1-6， 接Arduino的3-8；
 将两者合并，最简单的办法是更改landscape的判断条件。
 你问我为什么不改PID？
 因为如果按照landscape的接线，PID不仅error的正负反了，而且sensorvalues的权重也反了，这样Kp和Kd也得调。

**引脚对应情况**
车头向前，从左到右：

sensor pin|6|5|4|3|2|1
---|---|---|---|---|---|---
Arduino pin|3|4|5|6|7|8
sensorValues|0|1|2|3|4|5 

eg. 遇到左转弯，左边黑，右边白， 这样空间的左右和sensorvalues的从左到右是对应的

sensor pin| 6| 5| 4| 3| 2| 1
--|--|--|--|--|--|--                      
i|0| 1| 2| 3| 4| 5 
 sensorValuse[i]|1| 1| 1| 1| 0| 0|

**结论**：所以对landscape修改，T不变，左右转要对调即可。


## 改善转弯表现
  目前转弯的情况基本是：当车头的传感器到达弯道黑胶带处，一个轮子定住，另一个运动打弯转弯半径大的原因是传感器的位置不够靠前，解决办法：把传感器向前固定。
  实验发现：
 1. 速度调小到135效果更差；
 2. Kp改到0.7， Kd改到0.1 无明显变化，可以尝试更大的倍数。 
 
  分析：其实目前已经用了最大速度，所以更改Kp， Kd值没有效果，转弯的时候一个轮停住，另一个动，是自然的结果。 
 
  结果：最终，取消90的速度限制，车轮可以在转弯时反转。  
 

## 关于dead end的两种方案：
1. 用1个ultra sound传感器，当reflectance sensors检测到全为0或者全1000的时候，检测距离，在范围内就可以判断为dead end；
   * 原理：利用dead end和去掉线的地方到墙的距离不一样， ultra sound sensor可以得到距离的特点；
   * 优点：用传感器少，耗时也少； 
   * 缺点：需要实验，会不会错过T， 导致误判？
2. 用2个ultra sound传感器，分别装在前面和右边。当当reflectance sensors检测到全为0或者全1000的时候，判断是否前面和右边是否有墙。如果都有，左转，再判断，没有，则左转；有，则继续转90°，达到U-turn。
   * 优点：比方案一更稳妥；
   * 缺点：需要两次检测、中间要停下来，更耗时。
